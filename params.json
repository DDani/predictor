{"name":"Predictor","tagline":"Fast and efficient recommendations and predictions using Redis","body":"=======\r\nPredictor\r\n=========\r\n\r\nFast and efficient recommendations and predictions using Ruby & Redis. Used in production over at [Pathgather](http://pathgather.com) to recommend content to users.\r\n\r\n![](https://www.codeship.io/projects/5aeeedf0-6053-0131-2319-5ede98f174ff/status)\r\n\r\nOriginally forked and based on [Recommendify](https://github.com/paulasmuth/recommendify) by Paul Asmuth, so a huge thanks to him for his contributions to Recommendify. Predictor has been almost completely rewritten to\r\n* Be much, much more performant and efficient by using Redis for most logic.\r\n* Provide item similarities such as \"Users that read this book also read ...\"\r\n* Provide personalized predictions based on a user's past history, such as \"You read these 10 books, so you might also like to read ...\"\r\n\r\nAt the moment, Predictor uses the [Jaccard index](http://en.wikipedia.org/wiki/Jaccard_index) to determine similarities between items. There are other ways to do this, which we intend to implement eventually, but if you want to beat us to the punch, pull requests are quite welcome :)\r\n\r\nInstallation\r\n---------------------\r\n```ruby\r\ngem install predictor\r\n````\r\nor in your Gemfile:\r\n````\r\ngem 'predictor'\r\n```\r\nGetting Started\r\n---------------------\r\nFirst step is to configure Predictor with your Redis instance.\r\n```ruby\r\n# in config/initializers/predictor.rb\r\nPredictor.redis = Redis.new(:url => ENV[\"PREDICTOR_REDIS\"])\r\n\r\n# Or, to improve performance, add hiredis as your driver (you'll need to install the hiredis gem first\r\nPredictor.redis = Redis.new(:url => ENV[\"PREDICTOR_REDIS\"], :driver => :hiredis)\r\n```\r\nInputting Data\r\n---------------------\r\nCreate a class and include the Predictor::Base module. Define an input_matrix for each relationship you'd like to keep track of. This can be anything you think is a significant metric for the item: page views, purchases, categories the item belongs to, etc.\r\n\r\nBelow, we're building a recommender to recommend courses based off of:\r\n* Users that have taken a course. If 2 courses were taken by the same user, this is 3 times as important to us than if the courses share the same topic. This will lead to sets like:\r\n  * \"user1\" -> \"course-1\", \"course-3\",\r\n  * \"user2\" -> \"course-1\", \"course-4\"\r\n* Tags and their courses. This will lead to sets like:\r\n  * \"rails\" -> \"course-1\", \"course-2\",\r\n  * \"microeconomics\" -> \"course-3\", \"course-4\"\r\n* Topics and their courses. This will lead to sets like:\r\n  * \"computer science\" -> \"course-1\", \"course-2\",\r\n  * \"economics and finance\" -> \"course-3\", \"course-4\"\r\n\r\n```ruby\r\nclass CourseRecommender\r\n  include Predictor::Base\r\n\r\n  input_matrix :users, weight: 3.0\r\n  input_matrix :tags, weight: 2.0\r\n  input_matrix :topics, weight: 1.0\r\nend\r\n```\r\n\r\nNow, we just need to update our matrices when courses are created, users take a course, topics are changed, etc:\r\n```ruby\r\nrecommender = CourseRecommender.new\r\n\r\n# Add a single course to topic-1's items. If topic-1 already exists as a set ID, this just adds course-1 to the set\r\nrecommender.topics.add_single!(\"topic-1\", \"course-1\")\r\n\r\n# If your matrix is quite large, add_single! could take some time, as it must calculate the similarity scores\r\n# for course-1 across all other courses. If this is the case, use add_single and process the item at a more\r\n# convenient time, perhaps in a background job\r\nrecommender.topics.add_single(\"topic-1\", \"course-1\")\r\nrecommender.topics.process_item!(\"course-1\")\r\n\r\n# Add an array of courses to tag-1. Again, these will simply be added to tag-1's existing set, if it exists.\r\n# If not, the tag-1 set will be initialized with course-1 and course-2\r\nrecommender.tags.add_set!(\"tag-1\", [\"course-1\", \"course-2\"])\r\n\r\n# Or, just add the set and process whenever you like\r\nrecommender.tags.add_set(\"tag-1\", [\"course-1\", \"course-2\"])\r\n[\"course-1\", \"course-2\"].each { |course| recommender.topics.process_item!(course) }\r\n```\r\n\r\nAs noted above, it's important to remember that if you don't use the bang methods (add_set! and add_single!), you'll need to manually update your similarities (the bang methods will likely suffice for most use cases though). You can do so a variety of ways.\r\n* If you want to simply update the similarities for a single item in a specific matrix:\r\n  ````\r\n  recommender.matrix.process_item!(item)\r\n  ````\r\n* If you want to update the similarities for all items in a specific matrix:\r\n  ````\r\n  recommender.matrix.process!\r\n  ````\r\n* If you want to update the similarities for a single item in all matrices:\r\n  ````\r\n  recommender.process_item!(item)\r\n  ````\r\n* If you want to update all similarities in all matrices:\r\n  ````\r\n  recommender.process!\r\n  ````\r\n\r\nRetrieving Similarities and Recommendations\r\n---------------------\r\nNow that your matrices have been initialized with several relationships, you can start generating similarities and recommendations! First, let's start with similarities, which will use the weights we specify on each matrix to determine which courses share the most in common with a given course.\r\n```ruby\r\nrecommender = CourseRecommender.new\r\n\r\n# Return all similarities for course-1 (ordered by most similar to least).\r\nrecommender.similarities_for(\"course-1\")\r\n\r\n# Need to paginate? Not a problem! Specify an offset and a limit\r\nrecommender.similarities_for(\"course-1\", offset: 10, limit: 10) # Gets similarities 11-20\r\n\r\n# Want scores?\r\nrecommender.similarities_for(\"course-1\", with_scores: true)\r\n\r\n# Want to ignore a certain set of courses in similarities?\r\nrecommender.similarities_for(\"course-1\", exclusion_set: [\"course-2\"])\r\n```\r\n\r\nThe above examples are great for situations like \"Users that viewed this also liked ...\", but what if you wanted to recommend courses to a user based on the courses they've already taken? Not a problem!\r\n```ruby\r\nrecommender = CourseRecommender.new\r\n\r\n# User has taken course-1 and course-2. Let's see what else they might like...\r\nrecommender.predictions_for(item_set: [\"course-1\", \"course-2\"])\r\n\r\n# Already have the set you need stored in an input matrix? In our case, we do (the users matrix stores the courses a user has taken), so we can just do:\r\nrecommender.predictions_for(\"user-1\", matrix_label: :users)\r\n\r\n# Paginate too!\r\nrecommender.predictions_for(\"user-1\", matrix_label: :users, offset: 10, limit: 10)\r\n\r\n# Gimme some scores and ignore user-2....that user-2 is one sketchy fella\r\nrecommender.predictions_for(\"user-1\", matrix_label: :users, with_scores: true, exclusion_set: [\"user-2\"])\r\n```\r\n\r\nDeleting Items\r\n---------------------\r\nIf your data is deleted from your persistent storage, you certainly don't want to recommend that data to a user. To ensure that doesn't happen, simply call delete_item! on the individual matrix or recommender as a whole:\r\n```ruby\r\nrecommender = CourseRecommender.new\r\n\r\n# User removed course-1 from topic-1, but course-1 still exists\r\nrecommender.topics.delete_item!(\"course-1\")\r\n\r\n# course-1 was permanently deleted\r\nrecommender.delete_item!(\"course-1\")\r\n\r\n# Something crazy has happened, so let's just start fresh and wipe out all previously stored similarities:\r\nrecommender.clean!\r\n```\r\n\r\nProblems? Issues? Want to help out?\r\n---------------------\r\nJust submit a Gihub issue or pull request! We'd love to have you help out, as the most common library to use for this need, Recommendify, was last updated 2 years ago. We'll be sure to keep this maintained, but we could certainly use your help!\r\n\r\nThe MIT License (MIT)\r\n---------------------\r\nCopyright (c) 2014 Pathgather\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of\r\nthis software and associated documentation files (the \"Software\"), to deal in\r\nthe Software without restriction, including without limitation the rights to\r\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\r\nthe Software, and to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\r\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\r\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}